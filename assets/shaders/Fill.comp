#version 460 core

#define WG_SIZE 1024

layout(local_size_x = WG_SIZE, local_size_y = 1, local_size_z = 1) in;

#define MOVE_TO 0
#define LINE_TO 1
#define QUAD_TO 2
#define CUBIC_TO 3

#define GET_CMD_PATH_INDEX(value) (value >> 16)
#define GET_CMD_TYPE(value) ((value & 0x0000FF00) >> 8)

#define TILE_SIZE 16

struct BoundingBox
{
	vec4 minmax;
};

struct Path
{
	uint startCmdIndex;
	uint endCmdIndex;
	uint startTileIndex;
	uint endTileIndex;
	mat4 transform;
	BoundingBox bbox;
	uint color;
	uint startVisibleTileIndex;
	uint startSpanQuadIndex;
	uint startTileQuadIndex;
	bool isBboxVisible;
	uint _pad0;
	uint _pad1;
	uint _pad2;
};

struct Command
{
	uint pathIndexCmdType; // 16 bits pathIndex, 8 bits curve type, 8 bits unused, GET_CMD_PATH_INDEX, GET_CMD_TYPE, MAKE_CMD_PATH_INDEX, MAKE_CMD_TYPE
	uint startIndexSimpleCommands;
	uint endIndexSimpleCommands;
	uint _pad0;
	vec2 points[4]; // Maybe unused, but maximum 3 points for cubicTo
	vec2 transformedPoints[4]; // Maybe unused, but maximum 3 points for cubicTo
};

struct SimpleCommand // Lines or moves only
{
	uint type;
	vec2 point;
};

struct Increment
{
	int area;
	int height;
};

const uint MAX_UINT = 4294967295;
const float MAX_FLOAT = 3.40282347e+38F;

struct Tile
{
	int winding;
	uint nextTileIndex;
	bool hasIncrements;
	Increment[TILE_SIZE * TILE_SIZE] increments;
};

layout(std430, binding = 0) buffer Paths
{
	Path paths[];
};

layout(std430, binding = 1) buffer Commands
{
	Command commands[];
};

layout(std430, binding = 2) buffer SimpleCommands
{
	SimpleCommand simpleCommands[];
};

layout(std430, binding = 3) buffer Atomics
{
	uint atomic;
};

layout(std430, binding = 4) buffer Tiles
{
	Tile tiles[];
};

vec2 GetPreviousPoint(uint pathIndex, uint cmdIndex)
{
	Path path = paths[pathIndex];
	if (cmdIndex == path.startCmdIndex)
	{
		return vec2(0, 0);
	}

	Command cmd = commands[cmdIndex - 1];
	uint pathType = GET_CMD_TYPE(cmd.pathIndexCmdType);
	switch (pathType)
	{
	case MOVE_TO:
	case LINE_TO:
		return cmd.transformedPoints[0];
	case QUAD_TO:
		return cmd.transformedPoints[1];
	case CUBIC_TO:
		return cmd.transformedPoints[2];
	}
}

bool IsPointInsideViewSpace(in vec2 v)
{
	// TODO: Set for width and height of the window
	const float padding = 1.0;
	return !(v.x > 1900 + padding || v.x < 0 - padding || v.y > 1000 + padding || v.y < 0 - padding);
}

const int INSIDE = 0; // 0000
const int LEFT = 1;   // 0001
const int RIGHT = 2;  // 0010
const int BOTTOM = 4; // 0100
const int TOP = 8;    // 1000

int ComputeOutCode(in vec2 p)
{
	int code = INSIDE;

	if (p.x < 0.0f)
		code |= LEFT;
	else if (p.x > 1900.0)
		code |= RIGHT;
	if (p.y < 0.0f)
		code |= BOTTOM;
	else if (p.y > 1000.0)
		code |= TOP;

	return code;
}

bool IsLineInsideViewSpace(vec2 p0, vec2 p1)
{
	int outcode0 = ComputeOutCode(p0);
	int outcode1 = ComputeOutCode(p1);
	bool accept = false;

	while (true)
	{
		if (!bool(outcode0 | outcode1))
		{
			accept = true;
			break;
		}
		else if (bool(outcode0 & outcode1))
		{
			break;
		}
		else
		{
			float x, y;
			int outcodeOut = outcode1 > outcode0 ? outcode1 : outcode0;
			if (bool(outcodeOut & TOP))
			{
				x = p0.x + (p1.x - p0.x) * (1000 - p0.y) / (p1.y - p0.y);
				y = 1000;
			}
			else if (bool(outcodeOut & BOTTOM))
			{
				x = p0.x + (p1.x - p0.x) * (-p0.y) / (p1.y - p0.y);
				y = 0;
			}
			else if (bool(outcodeOut & RIGHT))
			{
				y = p0.y + (p1.y - p0.y) * (1900 - p0.x) / (p1.x - p0.x);
				x = 1900;
			}
			else if (bool(outcodeOut & LEFT))
			{
				y = p0.y + (p1.y - p0.y) * (-p0.x) / (p1.x - p0.x);
				x = 0;
			}

			if (outcodeOut == outcode0)
			{
				p0.x = x;
				p0.y = y;
				outcode0 = ComputeOutCode(p0);
			}
			else
			{
				p1.x = x;
				p1.y = y;
				outcode1 = ComputeOutCode(p1);
			}
		}
	}

	return accept;
}

bool IsBboxInsideViewSpace(in BoundingBox bbox)
{
	vec2 p1 = vec2(bbox.minmax.x, bbox.minmax.w);
	vec2 p2 = vec2(bbox.minmax.z, bbox.minmax.y);
	return IsLineInsideViewSpace(bbox.minmax.xy, bbox.minmax.zw) || IsLineInsideViewSpace(p1, p2);
}

vec2 GetSimpleCmdPrevPoint(uint simpleCmdIndex, in vec2 lastPoint, in Command cmd)
{
	return simpleCmdIndex == cmd.startIndexSimpleCommands ? lastPoint : simpleCommands[simpleCmdIndex - 1].point;
}

int m_TileStartX;
int m_TileStartY;
int m_TileCountX;
int m_TileCountY;

uint GetTileIndexFromRelativePos(int x, int y)
{
	return y * m_TileCountX + x;
}

uint GetTileIndexFromWindowPos(int x, int y)
{
	int offsetX = int(floor(float(x) / TILE_SIZE)) - m_TileStartX;
	int offsetY = int(floor(float(y) / TILE_SIZE)) - m_TileStartY;
	return offsetY * m_TileCountX + offsetX;
}

uint GetTileCoordX(int windowPosX)
{
	return int(floor(float(windowPosX) / TILE_SIZE)) - m_TileStartX;
}

uint GetTileCoordY(int windowPosY)
{
	return int(floor(float(windowPosY) / TILE_SIZE)) - m_TileStartY;
}

int GetTileXFromAbsoluteIndex(uint absIndex)
{
	uint offset = absIndex % m_TileCountX;
	return int(m_TileStartX + offset);
}

int GetTileYFromAbsoluteIndex(uint absIndex)
{
	uint offset = absIndex / m_TileCountX;
	return int(m_TileStartY + offset);
}

int Sign(float value)
{
	if (value > 0)
		return 1;
	else if (value < 0)
		return -1;
	return 0;
}

void LineToSimpleCmd(vec2 last, vec2 point, uint pathIndex)
{
	if (point != last)
	{
		uint prevTileY = GetTileCoordY(int(floor(last.y)));

		int xDir = Sign(point.x - last.x);
		int yDir = Sign(point.y - last.y);
		float dtdx = 1.0 / (point.x - last.x);
		float dtdy = 1.0 / (point.y - last.y);
		int x = int(floor(last.x)); // Convert to int
		int y = int(floor(last.y));  // Convert to int
		float rowt0 = 0.0;
		float colt0 = 0.0;

		float rowt1;
		if (last.y == point.y)
		{
			rowt1 = MAX_FLOAT;
		}
		else
		{
			float nextY = point.y > last.y ? y + 1 : y;
			rowt1 = min((dtdy * (nextY - last.y)), 1.0);
		}

		float colt1;
		if (last.x == point.x)
		{
			colt1 = MAX_FLOAT;
		}
		else
		{
			float nextX = point.x > last.x ? x + 1 : x;
			colt1 = min((dtdx * (nextX - last.x)), 1.0f);
		}

		float xStep = abs(dtdx);
		float yStep = abs(dtdy);

		while (true)
		{
			float t0 = max(rowt0, colt0);
			float t1 = min(rowt1, colt1);
			vec2 p0 = (1.0f - t0) * last + t0 * point;
			vec2 p1 = (1.0f - t1) * last + t1 * point;
			float height = p1.y - p0.y;
			float right = x + 1;
			float area = 0.5f * height * ((right - p0.x) + (right - p1.x));

			int relativeX = abs(x % TILE_SIZE);
			int relativeY = abs(y % TILE_SIZE);
			if (x < 0)
			{
				relativeX = TILE_SIZE - relativeX - 1;
			}
			if (y < 0)
			{
				relativeY = TILE_SIZE - relativeY - 1;
			}

			atomicAdd(tiles[paths[pathIndex].startTileIndex + GetTileIndexFromWindowPos(x, y)].increments[relativeY * TILE_SIZE + relativeX].area, int(area * 1000.0));
			atomicAdd(tiles[paths[pathIndex].startTileIndex + GetTileIndexFromWindowPos(x, y)].increments[relativeY * TILE_SIZE + relativeX].height, int(height * 1000.0f));
			tiles[paths[pathIndex].startTileIndex + GetTileIndexFromWindowPos(x, y)].hasIncrements = true;

			// Advance to the next scanline
			if (rowt1 < colt1)
			{
				rowt0 = rowt1;
				rowt1 = min((rowt1 + yStep), 1.0);
				y += yDir;
			}
			else
			{
				colt0 = colt1;
				colt1 = min((colt1 + xStep), 1.0);
				x += xDir;
			}

			// Reset coordinates if a scanline is completed
			if (rowt0 == 1.0 || colt0 == 1.0)
			{
				x = int(floor(point.x));
				y = int(floor(point.y));
			}

			// Handle tile boundaries
			uint tileY = GetTileCoordY(y);
			if (tileY != prevTileY)
			{
				uint v1 = GetTileCoordX(x); // Find out which tile index on x-axis are we on
				int v2 = int(tileY - prevTileY); // Are we moving from top to bottom, or bottom to top? (1 = from lower tile to higher tile, -1 = opposite)
				uint currentTileY = v2 == 1 ? prevTileY : tileY;

				Path path = paths[pathIndex];
				uint tileCount = path.endTileIndex - path.startTileIndex + 1;
				uint currentIndex = max(min(GetTileIndexFromRelativePos(int(v1), int(currentTileY)), uint(tileCount - 1)), 0);

				{
					for (uint i = 0; i < currentIndex; i++)
					{
						atomicAdd(tiles[i + path.startTileIndex].winding, v2);
					}
				}

				prevTileY = tileY;
			}

			// Break the loop if we are on the end
			if (rowt0 == 1.0f || colt0 == 1.0f)
			{
				break;
			}
		}
	}
}

void CommandFromArray(uint i, in vec2 lastPoint, in Command cmd)
{
	const SimpleCommand simpleCmd = simpleCommands[i];
	vec2 last = GetSimpleCmdPrevPoint(i, lastPoint, cmd);
	uint pathIndex = GET_CMD_PATH_INDEX(cmd.pathIndexCmdType);

	switch (simpleCmd.type)
	{
	case LINE_TO:
		LineToSimpleCmd(last, simpleCmd.point, pathIndex);
		break;
	}
}

shared uint numIter;

void main()
{
	uint cmdIndex = gl_WorkGroupID.y * gl_NumWorkGroups.x + gl_WorkGroupID.x;
	if (cmdIndex < commands.length())
	{
		Command cmd = commands[cmdIndex];
		uint pathIndex = GET_CMD_PATH_INDEX(cmd.pathIndexCmdType);
		Path path = paths[pathIndex];

		if (IsBboxInsideViewSpace(path.bbox))
		{
			if (gl_LocalInvocationIndex == 0)
			{
				numIter = uint(ceil((path.endCmdIndex - path.startCmdIndex + 1) / float(WG_SIZE)));
			}
		}
	}

	barrier(); // TODO: Only for single workgroup

	if (cmdIndex < commands.length())
	{
		Command cmd = commands[cmdIndex];
		uint pathIndex = GET_CMD_PATH_INDEX(cmd.pathIndexCmdType);
		Path path = paths[pathIndex];

		if (IsBboxInsideViewSpace(path.bbox))
		{
			// TODO: We are not interested in tiles, where x-coord of the tile is above SCREEN_WIDTH, or y-coord is above SCREEN_HEIGHT
			const int minBboxCoordX = int(floor(path.bbox.minmax.x));
			const int minBboxCoordY = int(floor(path.bbox.minmax.y));
			const int maxBboxCoordX = int(ceil(path.bbox.minmax.z));
			const int maxBboxCoordY = int(ceil(path.bbox.minmax.w));

			const int minTileCoordX = int(floor(float(minBboxCoordX) / TILE_SIZE));
			const int minTileCoordY = int(floor(float(minBboxCoordY) / TILE_SIZE));
			const int maxTileCoordX = int(ceil(float(maxBboxCoordX) / TILE_SIZE));
			const int maxTileCoordY = int(ceil(float(maxBboxCoordY) / TILE_SIZE));

			m_TileStartX = minTileCoordX;
			m_TileStartY = minTileCoordY;
			m_TileCountX = maxTileCoordX - minTileCoordX + 1;
			m_TileCountY = maxTileCoordY - minTileCoordY + 1;

			vec2 last = GetPreviousPoint(pathIndex, cmdIndex);

			for (uint i = 0; i < numIter; i++)
			{
				uint simpleCmdIndex = cmd.startIndexSimpleCommands + (i * WG_SIZE) + gl_LocalInvocationIndex;
				if (simpleCmdIndex <= cmd.endIndexSimpleCommands)
				{
					CommandFromArray(simpleCmdIndex, last, cmd);
				}
			}
		}
	}
}